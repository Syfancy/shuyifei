#ifndef MYSTRING_H
#define MTSTRING_H

#include <malloc.h>
#include <cstring>
#include <cassert>
#include <cwchar>


template<typename charT>
class myString
{
public:
    typedef charT* iterator;
private:
    size_t m_length;
    size_t m_capacity;
    iterator m_begin;
    iterator m_end;

private:
    iterator alloc(size_t n); //内存分配器

public:
    /*
    * 构造函数和析构函数
    */
    myString(const charT*);
    myString();
    ~myString();

public:
    /*
    * 重载 = 运算符
    */
    myString& operator= (const myString&);
    myString& operator= (const charT*);
    myString& operator= (charT);

public:
    /*
    * 迭代器
    */
    const iterator begin()const;
    const iterator end()const;
    /*
    * 重载 [] 运算符
    */
    charT& operator[](size_t);

public:
    /*
    * 功能函数
    */
    const size_t size()const;
    const size_t max_size()const;
    void resize(size_t, charT);
    void resize(size_t n);
    const charT* c_str()const;
};//class myString



//内存分配器
template<typename charT>
inline typename myString<charT>::iterator myString<charT>::alloc(size_t n)
{
    m_capacity = n;
    return (charT*)calloc(n, sizeof(charT));
}

//字符串为参数的构造函数
template<typename charT>
inline myString<charT>::myString(const charT* str)
    :m_length(strlen((char*)str) / sizeof(charT)),
    m_capacity(m_length + m_length / 5 + 1),
    m_begin(alloc(m_capacity)),
    m_end(m_begin + m_length)
{
    assert(m_length < max_size());

    strcpy((char*)m_begin, (char*)str);
    *m_end = '\0';
}

//默认的无参构造函数
template<typename charT>
inline myString<charT>::myString()
    :m_length(0),
    m_begin(alloc(1)),
    m_end(0)
{
    *m_begin = '\0';
}

//析构函数
template<typename charT>
inline myString<charT>::~myString()
{
    free(m_begin);
}

//重载 = 运算符
template<typename charT>
inline myString<charT>& myString<charT>::operator= (const myString& str)
{
    m_length = str.size();

    assert(m_length < max_size());

    if (m_capacity <= m_length)//动态分配存储空间
    {
        free(m_begin);
        m_begin = alloc(m_length + m_length / 5 + 1);
    }

    strcpy((char*)m_begin, (char*)str.c_str());
    m_end = m_begin + m_length;

    return *this;
}
template<typename charT>
inline myString<charT>& myString<charT>::operator= (const charT* pstr)
{
    m_length = strlen((char*)pstr) / sizeof(charT);

    assert(m_length < max_size());

    if (m_capacity <= m_length)
    {
        free(m_begin);
        m_begin = alloc(m_length + m_length / 5 + 1);
    }

    strcpy((char*)m_begin, (char*)pstr);
    m_end = m_begin + m_length;

    return *this;
}
template<typename charT>
inline myString<charT>& myString<charT>::operator= (charT c)
{
    m_length = 1;
    m_end = m_begin + m_length;

    if (m_capacity <= 1)
    {
        free(m_begin);
        m_begin = alloc(2);
    }

    *m_begin = c;
    return *this;
}

//迭代器
template<typename charT>
inline const typename myString<charT>::iterator myString<charT>::begin()const
{
    return m_begin;
}
template<typename charT>
inline const typename myString<charT>::iterator myString<charT>::end()const
{
    return m_end;
}

//重载 [] 运算符
template<typename charT>
charT& myString<charT>::operator[](size_t pos)
{
    return m_begin[pos];
}

//允许放入容器的最大元素数目
template<typename charT>
inline const size_t myString<charT>::max_size()const
{
    //因为要在最后放'\0'，所以-1
    return size_t(-1) / sizeof(charT*) - 1;
}

//获取字符串长度
template<typename charT>
inline const size_t myString<charT>::size()const
{
    return m_length;
}

//改变字符串长度，并且对多出的部分进行填充（如果有多出的话）
template<typename charT>
void myString<charT>::resize(size_t n, charT c)
{
    charT* tmp = m_begin;
    int i;
    m_begin = alloc(n + 1);
    m_end = m_begin + n;

    memcpy((char*)m_begin, (char*)tmp, (n < m_length ? n : m_length) * sizeof(charT));

    m_length = strlen((char*)m_begin) / sizeof(charT);
    for (i = m_length; i < n; i++)
    {
        m_begin[i] = c;
    }
    *m_end = '\0';
    free(tmp);
}

//改变字符串长度，不进行别的操作
template<typename charT>
void myString<charT>::resize(size_t n)
{
    charT* tmp = m_begin;
    m_begin = alloc(n + 1);
    m_end = m_begin + n;

    memcpy((char*)m_begin, (char*)tmp, (n < m_length ? n : m_length) * sizeof(charT));

    m_length = strlen((char*)m_begin) / sizeof(charT);
    free(tmp);
}

//转换为C风格的字符串
template<typename charT>
inline const charT* myString<charT>::c_str()const
{
    return m_begin;
}

typedef myString<char> String;
typedef myString<wchar_t> WString;


#endif